\section{Survey of Current Landscape}

\fixme{(authors: Anders, Brett, all)}

This section presents a general overview of the current landscape of
HEP libraries and tools.  
%
First, general patterns that run counter to cross-experiment sharing
are listed.
%
% what about general beneficial patterns?
%
Finally a prioritized list of activities and where involvement by the
HEP-FCE could be beneficial.

\subsection{Forces Counter to Cross-experiment Software}

Sharing software libraries and tools between experiment more
frequently than is currently done is expected, by the group, to
increase overall productivity.  Independent of cross-experiment
sharing, designing and implementing software in a more general manner
is expected to be beneficial.  The working group
identified some reasons why such general use software is not as
predominant as it could be.

\subsubsection{Up-front Effort}

Designing and implementing software to solve a general problem instead
of the specific instance faced by one experiment can take more effort
initially.  Solving ``just'' the problem one immediately faces is
cheaper in the immediate time scale.  If the problem is short lived
and the software abandoned this strategy can be a net-benefit.  What
is more often the case, fixes to new problems compound the problem and
the software becomes either brittle and narrowly focused, increasingly
difficult to maintain, and ever less able to be extended.

\subsubsection{Lack of Expertise}

Physicist have always been multidisciplinary, covering all aspects of
an experiment from hardware design, bolt turning, operations, project
management, data analyst and software developer.  As data rates
increased, algorithms become more complex, networking, storage and
computation technology advanced, the requirements for a Physicist to
be software developer have become more challenging to meet while
maintaining needed capabilities in the other
disciplines.  As a consequence, some experiments, especially the smaller
ones, lack the software expertise and knowledge of what is available
needed to develop general software solutions or adopt existing ones.
This leads to the same result of solving ``just'' the immediate
problem and associated consequences described above.

\subsubsection{Ignoring Software Design Patterns}

A specific example of lack of expertise manifests in developers who
ignore basic, tried and true software design patterns.  This can be
seen in software that lacks any notion of interfaces or layering
between different functionality.  Often new features are developed by
finding a spot that ``looks good'' and pasting in some more code to
achieve an immediate goal with no understanding of the long-term consequences.
Like the ``up-front'' costs problem, this strategy is often rewarded as the
individual produces desired results quickly and the problem that this change
causes is not made apparent until later.

\subsubsection{Limited Support}

Some experiments have a high degree of software expertise.  These
efforts may even naturally produce software that can have some
cross-experiment benefit.  However, they lack the necessary ability to
support their developers to make the final push needed to offer that
software more broadly.  In many cases they also do not have the ability
to assure continued support of the software for its use by others.
In the best cases, some are able to provide support on a limited or best effort basis.  
While this helps others adopt the software it still leaves room
for improvements.  A modest amount of expert time can save a large amount of time of many novices.

\subsubsection{Transitory Members}

Many software developers in an experiment are transitory.  After
graduate students and post-docs make a contribution to the software
development and the experiment in general they typically move on to
other experiments in the advancement of their careers.  In part, this migration
can help disseminate software between experiments but it also
posses a problem of retaining a nucleus of long-term knowledge and
support around the software they developed.

\subsubsection{Parochial View}

In some cases, beneficial software sharing is hampered by experiments,
groups, labs, etc which suffer from the infamous ``not invented here''
syndrome.  A parochial view leads to preferring solutions to come from
within the unit rather than venturing out and surveying a broader
landscape where better, more general solutions are likely to be found.
Parochialism compounds itself by making it ever more difficult for
motivated people to improve the entranced systems by bringing in more 
general solutions.

\subsubsection{Discounting the Problem}

There is a tendency with some Physicists to discount software and
computing solutions.  The origin of this viewpoint may be due to the
individual having experience from a time where software and computing
solutions were indeed not as important as they are now.  It may also
come as a consequence of that person enjoying the fruits of high
quality software and computing environments and being ignorant of the
effort needed to provide and maintain them.  Whatever the origin,
underestimating the importance of developing quality software tools leads
to inefficiency and lack of progress. 

\subsubsection{Turf Wars}

Software development is a personal and social endeavor.  It is natural
for someone who takes pride in that work to become personally attached
to the software they develop.  In some cases this can color judgment
leading to retaining software in its current state where it may be
more beneficial to refactor or discard and reimplement.  What are
really prototypes can become too loved to be replaced.

\subsubsection{Perceived Audience and Development Context}

The group made the observation that cues from the audience for the
software and the context in which it is developed lead to shifts in
thinking about a software design.  For example, resulting designs tend to be more narrowly
applicable when one knows that the code will be committed to a private
repository only accessible by a single collaboration.  On the other hand, 
when one is pushing commits to a repository that is fully accessible
by a wide public audience one naturally thinks about broader use cases and 
solutions to more general problems.

\subsubsection{Disparate Communications}

Different experiments and experiment-independent software projects
have differing means of communicating.  Technical support, knowledge
bases, software repositories, bug trackers, release announcements are
all areas that have no standard implementation.  Some groups even
have multiple types of any of these means of communication.
Independent of this, different policies mean that not all information
may be publicly available.  These all pose a hurdles for the sharing of 
software between these groups.

\subsubsection{Design vs. Promotion}

For general purpose software to be beneficial across multiple
experiments it needs at least two things.  It needs to be well
designed and implemented that that is actually general purpose.  It
also needs to be promoted in a way that potential adopters learn of
its suitability.  Often the set of individuals that excel at the
former and excel at the latter has little overlap.

\subsubsection{Decision Making}

An experiment's software is no better than the best software expert
involved in the decision making process used to provide it. And it's often worse.
Decision making is a human action and as such it can suffer from being
driven by the loudest argument and not necessarily the one most sound.
Many times, choices are made in a vacuum lacking suitable opposition.
At times they are made without a decision-making policy and procedures in place or
ignored if one exists, or if followed, without sufficient information
to make an informed decision.  Politics and familiarity can trump
rationality and quality.

\subsubsection{Getting off on the wrong foot}

There is often no initial review of what software is available when a new experiment begins.
Frequently a Physicist charged with software duties on an experiment will 
jump in and begin to do things the way that they were done in their 
last project, thus propagating and baking in inefficencies for another generation.  
No time will be spent to see what has changed since an earlier experiment's 
software design, and whole evolutions in ways of thinking or recently available
tools updates may be missed.

\subsubsection{Editing notes}

\fixme{This is not a real section and will be deleted}

\begin{itemize}
\item Give our understanding of the situation with libs/tools in HEP:
  \begin{itemize}
  \item General purpose libraries (I/O, statistical analysis, linear algebra)
  \item Data management and transfer tools
  \item Code management utilities
  \item High Throughput Computing (HTC) tools and services
  \item Graphics packages
  \item Documentation tools
  \item Build/release/scripting/testing tools
  \end{itemize}
\item describe overlap between libs/tools and the applications and systems groups
  \begin{itemize}
  \item attempt made to keep covered topics distinct from other two HEP-FCE groups
  \item work\textbf{flow} vs work\textbf{load} mgt
  \item geant4/ROOT as application or as lib/tool
  \end{itemize}
\item describe how libraries and tools tend to be reinvented for each major experiment 
\item describe the effort to adopt libs/tools from other experiments (Daya Bay: DBI from MINOS, SPADE from IceCube, Gaudi/GiGa/DetDesc from LHCb)
\item library-level parochialism (some possible topics):
  \begin{itemize}
  \item no time/effort/expertise to step back from immediate problem to look at bigger picture design (post-doc reads Geant4 manual, hacks up an application based on one of the examples and then stuff just starts to organically grow)
  \item single, monolithic geant4 application becomes center of analysis for whole experiment, everyone piles on
  \item inject ``just a few lines of code here'' instead of refactor
  \item configuration through code modification and recompilation
  \item cut-and-paste source code sharing instead of modules in shared libraries
  \item linkage of implementation code in shared libraries instead of proper pure-Interface libraries (C++)
  \item framework tendrils work their way throughout all code
  \item no framework (or even with a framework) leads to data-file-as-module-interface (I/O inefficient, scales poorly to large processing or complex workflows)
  \item heavy framework enforcing execution model (eg, I want to be
    able to test my code via interactive \texttt{ipython} prompt
    \textbf{and} have it run from a framework ``algorithm/module'')
  \end{itemize}
\item Social/psychological - maybe belongs in its own ``area of opportunity''?
  \begin{itemize}
\item collaborations lack support/time, or feel like the do, to write or adopt general purpose libs/tools and then support them going forward.
\item the community as a whole lacks common communication tools, rather individual projects/experiments all have their own way of doing things, or not at all.  Some tools are counter productive (eg, choosing web fora over email lists for conversations)
\item Communities that attempt to establish are often not responsive enough to users to maintain themselves.  Strive for a community healthy enough to have developers supporting experts, experts supporting users and users supporting newbies.
\item reward desired behavior: be gracious with bug reports, welcome and record feature requests from users and sometimes even satisfy them, thank and credit community members who contribute, do this in a non-BS, non-PR way (no auto email replies!)
\item Expertise in writing good, general-purpose libs/tools does not always imply expertise in promoting/advertising the software.  Need ways to uncover hidden diamonds.
\item An experiment's software is no better than the best software expert involved.
\item Loudest is not always best.
\item Large software decisions are often made without critical opposition, without a decision making policy in place, or ignored if one exists, and without full information readily available to form an objective selection.
\item Politics and familiarity often trump rationality and quality in selecting software or software strategies.
\item Prototypes become too loved to be replaced.
\item Proper software design and experience is looked down on as a hindrance by those who work closer to the Physics.
\item Software developers often design to the lowest user instead of expecting the users to be able to lift themselves up to the higher design.
\item Many decisions are made based on what may happen not what is likely to happen.
  \end{itemize}

\item Intro to remaining specific problems:
\begin{itemize}
\item the specific areas of opportunity identified as important where improvement (cross-cutting) has potential to help many.
\item First two have a relatively large phase space with many sub components, second two are somewhat smaller in scope.
\end{itemize}

\end{itemize}
\textit{(end of notes)  }

\subsection{Areas of Opportunity}

Each of the following sections focus on one particular \textit{area of opportunity} to make improvements in how the community shares libs/tools between experiments.  In each area of opportunity we present:

\begin{itemize}
\item A description of the area.
\item A number of case studies of existing or past software libraries and tools including concrete examples of what works and what does not.
\item Specific aspects that need improvement and an estimation of what efforts would be needed to obtain that.
\end{itemize}
